{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (\n  target: { [key: string]: Function | Function[] } | undefined,\n  source: { [key: string]: Function | Function[] } | undefined\n) {\n  if (!target) return source\n  if (!source) return target\n\n  let event: string\n\n  for (event of Object.keys(source)) {\n    // Concat function to array of functions if callback present.\n    if (target[event]) {\n      // Insert current iteration data in beginning of merged array.\n      target[event] = wrapInArray(target[event])\n      ;(target[event] as Function[]).push(...wrapInArray(source[event]))\n    } else {\n      // Straight assign.\n      target[event] = source[event]\n    }\n  }\n\n  return target\n}\n"],"sourceRoot":"","file":"mergeData.js"}